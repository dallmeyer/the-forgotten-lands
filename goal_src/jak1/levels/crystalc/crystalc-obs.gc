;;-*-Lisp-*-
(in-package goal)
(deftype breakaway (process-drawable)
  ((root collide-shape-moving :override))
  (:methods
   (init! (_type_ res-lump int) none)
   (go-idle (_type_) none))
  (:states
   breakaway-about-to-fall
   breakaway-fall
   breakaway-idle))

(defstate breakaway-idle (breakaway)
  :event
    (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
      (case arg2
        (('touch) (send-event arg0 'no-look-around (seconds 1.5)) (go breakaway-about-to-fall))))
  :code anim-loop
  :post transform-post)

(defun actor-wait-for-period ((arg0 time-frame))
  (let ((s5-0 (-> *display* base-frame-counter))) (while (< (- (-> *display* base-frame-counter) s5-0) arg0) (suspend)))
  #f)

(defstate breakaway-about-to-fall (breakaway)
  :code
    (behavior ()
      (sound-play "falling-bones")
      (launch-particles (-> *part-id-table* 281) (-> self root trans))
      (let ((gp-1 #f)
            (s5-1 (-> *display* base-frame-counter)))
        (loop
          (ja-no-eval :group! (ja-group) :num! (seek! (ja-aframe 15.0 0)) :frame-num (ja-aframe 1.0 0))
          (until (ja-done? 0)
            (when (and (not gp-1) (>= (- (-> *display* base-frame-counter) s5-1) (seconds 0.15)))
              (set! gp-1 #t)
              (send-to-next-and-prev (-> self link) 'touch))
            (if (>= (- (-> *display* base-frame-counter) s5-1) (seconds 0.25)) (go breakaway-fall))
            (suspend)
            (ja :num! (seek! (ja-aframe 15.0 0))))))
      (none))
  :post rider-post)

(defstate breakaway-fall (breakaway)
  :code
    (behavior ()
      (let ((f30-0 0.0)
            (f28-0 0.0)
            (f26-0 (* 0.1 (- (-> *standard-dynamics* gravity-length)))))
        (ja-no-eval :group! (ja-group) :num! (seek! (ja-aframe 32.0 0) 0.4) :frame-num (ja-aframe 16.0 0))
        (until (ja-done? 0)
          (+! f30-0 (* f28-0 (-> *display* seconds-per-frame)))
          (+! f28-0 (* f26-0 (-> *display* seconds-per-frame)))
          (+! (-> self root trans y) f30-0)
          (suspend)
          (ja :num! (seek! (ja-aframe 32.0 0) 0.4))))
      (cleanup-for-death self)
      (none))
  :post rider-post)

(defmethod init! ((this breakaway) (arg0 res-lump) (arg1 int))
  (set! (-> this mask) (logior (process-mask platform) (-> this mask)))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (alloc-riders s4-0 1)
    (let ((s2-0 (new 'process 'collide-shape-prim-mesh s4-0 (the uint 0) (the uint 0))))
      (set! (-> s2-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s2-0 collide-with) (collide-kind target))
      (set! (-> s2-0 prim-core action) (collide-action solid))
      (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s2-0 transform-index) arg1)
      (set-vector! (-> s2-0 local-sphere) 8192.0 -4096.0 8192.0 16384.0)
      (set-root-prim! s4-0 s2-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0))
  (set! (-> this link) (new 'process 'actor-link-info this))
  (process-drawable-from-entity! this (the entity-actor arg0))
  (none))

(defmethod go-idle breakaway
  ((this breakaway))
  (go breakaway-idle)
  (none))

(deftype breakaway-right (breakaway) ())

(deftype breakaway-mid (breakaway) ())

(deftype breakaway-left (breakaway) ())

(defskelgroup *breakaway-right-sg*
  breakaway-right
  breakaway-right-lod0-jg
  breakaway-right-idle-ja
  ((breakaway-right-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 7))

(defskelgroup *breakaway-mid-sg*
  breakaway-mid
  breakaway-mid-lod0-jg
  breakaway-mid-idle-ja
  ((breakaway-mid-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 7))

(defskelgroup *breakaway-left-sg*
  breakaway-left
  breakaway-left-lod0-jg
  breakaway-left-idle-ja
  ((breakaway-left-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 7))

(defmethod init-from-entity! ((this breakaway-right) (arg0 entity-actor))
  (init! this arg0 3)
  (initialize-skeleton this *breakaway-right-sg* '())
  (go-idle this)
  (none))

(defmethod init-from-entity! ((this breakaway-mid) (arg0 entity-actor))
  (init! this arg0 3)
  (initialize-skeleton this *breakaway-mid-sg* '())
  (go-idle this)
  (none))

(defmethod init-from-entity! ((this breakaway-left) (arg0 entity-actor))
  (init! this arg0 3)
  (initialize-skeleton this *breakaway-left-sg* '())
  (go-idle this)
  (none))

(defskelgroup *electric-arc-sg*
  money
  money-lod0-jg
  money-idle-ja
  ((money-lod0-mg (meters 20)) (money-lod1-mg (meters 40)) (money-lod2-mg (meters 999999)))
  :bounds (static-spherem 0 3 0 4)
  :texture-level 2)

(deftype electric-arc (process-drawable)
  ((cshape             collide-shape :overlay-at root)
   (shove-up           float)
   (cycle-speed        int32)
   (cycle-pause        int32)
   (cycle-offset       uint32)
   (was-deadly?        symbol)
   (should-play-sound? symbol)
   (launch-pos         vector 2 :inline))
  (:states
   electric-arc-active))

(defstate electric-arc-active (electric-arc)
  :event
    (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
      (case event-type
        (('touch 'attack)
         (when (= (-> proc type) target)
           (when (prims-touching-action? (the touching-shapes-entry (-> event param 0))
                                         (-> *target* control)
                                         (collide-action solid)
                                         (collide-action))
             (let ((s4-0 (new 'stack 'attack-info)))
               (calc-shove-up (-> self cshape) s4-0 (-> self shove-up))
               (if (or (= (-> *target* control unknown-surface00 mode) 'air)
                       (>= (+ (-> *display* base-frame-counter) (seconds -0.2)) (-> *target* control unknown-dword11))
                       (< 0.75 (-> *target* control poly-normal y)))
                 (send-event proc
                             'attack-or-shove
                             (-> event param 0)
                             (static-attack-info ((mode 'burn) (vector (-> s4-0 vector)) (shove-up (-> s4-0 shove-up)))))
                 (send-event proc
                             'attack-or-shove
                             (-> event param 0)
                             (static-attack-info ((mode 'burn) (shove-up (meters 0)) (shove-back (meters 2)) (vector (-> *target* control poly-normal)) (angle 'shove)))))))))))
  :trans
    (behavior ()
      (let* ((v1-0 (-> self cycle-speed))
             (a0-1 (- v1-0 (-> self cycle-pause)))
             (gp-0 (mod (+ (current-time) (the time-frame (-> self cycle-offset))) v1-0)))
        (cond
          ((< gp-0 a0-1)
           (when (sphere-in-view-frustum? (the sphere (-> self cshape root-prim prim-core)))
             (launch-particles (-> *part-id-table* 3048) (the vector (-> self launch-pos))) ;; Moved to crystalc-part.gc
             (launch-particles (-> *part-id-table* 3049) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3050) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3051) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3052) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3053) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3054) (the vector (-> self launch-pos))))
           (awhen (level-get *level* 'crystal-cave)
                  (set-vector! *crystalc-ship-dir2* 0.3 0.4 1.6 1.0)
                  (set-vector! *crystalc-ship-ambi* 0.1 0.3 0.6 1.0))
           (update! (-> self sound))
           (update-vol! (-> self sound) 160)
           (cond
             ((-> self should-play-sound?)
              (set! (-> self should-play-sound?) #f)
              ;; (update-vol! (-> self sound) 1500)
              ))
           (cond
             ((< gp-0 30) (when (-> self was-deadly?) (set! (-> self was-deadly?) #f) (clear-collide-with-as (-> self cshape))))
             (else (when (not (-> self was-deadly?)) (set! (-> self was-deadly?) #t) (restore-collide-with-as (-> self cshape)))))
           (when (and (not (-> self was-deadly?)) (< 60 gp-0))
             (set! (-> self was-deadly?) #t)
             (restore-collide-with-as (-> self cshape))))
          (else
           (set! (-> self should-play-sound?) #t)
           (update-vol! (-> self sound) 1)
           (awhen (level-get *level* 'crystal-cave)
                  (set-vector! *crystalc-ship-dir2* 1.5 0.0 1.2 1.0)
                  (set-vector! *crystalc-ship-ambi* 0.2 0.2 0.7 1.0))
           (when (-> self was-deadly?)
             (set! (-> self was-deadly?) #f)
             (clear-collide-with-as (-> self cshape))))))
      (none))
  :code
    (behavior ()
      (loop
        (logior! (-> self mask) (process-mask sleep-code))
        (suspend))
      (none))
  :post
    (behavior ()
      (ja-post)
      (logior! (-> self draw status) (draw-status hidden))
      (none)))

(defmethod init-from-entity! electric-arc
  ((this electric-arc) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> this was-deadly?) #f)
  (set! (-> this should-play-sound?) #f)
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default 8192.0))
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player)))) ;; Vectors for hitbox
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the uint 12) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) (meters 0.0) (meters 12.0) (meters 0.0) (meters 24.0))
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-0 local-sphere) (meters 0.0) (meters 0.0) (meters 0.0) (meters 4.0))
        (append-prim s3-0 s2-0))
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-1 local-sphere) (meters -0.30) (meters 5.99) (meters -0.05) (meters 4.0))
        (append-prim s3-0 s2-1))
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-2 local-sphere) (meters -0.60) (meters 11.98) (meters -0.11) (meters 4.0))
        (append-prim s3-0 s2-2))
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-3 local-sphere) (meters -0.91) (meters 17.97) (meters -0.17) (meters 4.0))
        (append-prim s3-0 s2-3))
      (let ((s2-4 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-4 collide-with) (collide-kind target))
        (set! (-> s2-4 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-4 local-sphere) (meters -1.21) (meters 23.96) (meters -0.23) (meters 4.0))
        (append-prim s3-0 s2-4))
      (let ((s2-5 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-5 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-5 collide-with) (collide-kind target))
        (set! (-> s2-5 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-5 local-sphere) (meters -7.86) (meters 24.37) (meters -1.60) (meters 3.0))
        (append-prim s3-0 s2-5))
      (let ((s2-6 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-6 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-6 collide-with) (collide-kind target))
        (set! (-> s2-6 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-6 local-sphere) (meters -9.83) (meters 19.28) (meters -1.93) (meters 3.0))
        (append-prim s3-0 s2-6))
      (let ((s2-7 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-7 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-7 collide-with) (collide-kind target))
        (set! (-> s2-7 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-7 local-sphere) (meters -11.76) (meters 14.28) (meters -2.26) (meters 3.0))
        (append-prim s3-0 s2-7))
      (let ((s2-8 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-8 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-8 collide-with) (collide-kind target))
        (set! (-> s2-8 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-8 local-sphere) (meters -13.75) (meters 9.14) (meters -2.59) (meters 3.0))
        (append-prim s3-0 s2-8))
      (let ((s2-9 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-9 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-9 collide-with) (collide-kind target))
        (set! (-> s2-9 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-9 local-sphere) (meters 5.69) (meters 24.37) (meters 1.16) (meters 3.0))
        (append-prim s3-0 s2-9))
      (let ((s2-10 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-10 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-10 collide-with) (collide-kind target))
        (set! (-> s2-10 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-10 local-sphere) (meters 8.65) (meters 22.09) (meters 1.76) (meters 3.0))
        (append-prim s3-0 s2-10))
      (let ((s2-11 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-11 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-11 collide-with) (collide-kind target))
        (set! (-> s2-11 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-11 local-sphere) (meters 11.62) (meters 19.81) (meters 2.36) (meters 3.0))
        (append-prim s3-0 s2-11)))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this cshape) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *electric-arc-sg* '())
  (set! (-> this sound)
        (new 'process
             'ambient-sound
             (static-sound-spec "blue-eco-idle" :fo-min 30 :fo-max 100 :volume 1500)
             (-> this cshape trans)))
  ;; (logior! (-> this draw status) (draw-status hidden))
  (let ((v1-42 (new 'process 'path-control this 'path 0.0)))
    (set! (-> this path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0) (go process-drawable-art-error "no path")))
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0) (quaternion-rotate-y! (-> this cshape quat) (-> this cshape quat) f0-23)))
  (let ((f30-0 (quaternion-y-angle (-> this cshape quat))))
    (let ((s4-1 (-> this launch-pos)))
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) 6144.0)
        (set! (-> v1-53 0 y) 0.0)
        (set! (-> v1-53 0 z) 0.0)
        (set! (-> v1-53 0 w) 1.0))
      (vector-rotate-around-y! (the vector s4-1) (the vector s4-1) f30-0)
      (vector+! (the vector s4-1) (the vector s4-1) (-> this cshape trans)))
    (let ((s4-2 (the object (&-> this stack 112))))
      (set-vector! (the vector s4-2) -6144.0 0.0 0.0 1.0)
      (vector-rotate-around-y! (the vector s4-2) (the vector s4-2) f30-0)
      (vector+! (the vector s4-2) (the vector s4-2) (-> this cshape trans)))
    (let ((s4-3 (-> this cshape root-prim)))
      (dotimes (s3-1 (-> (the collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)))))
  (update-transforms! (-> this cshape))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> this cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the int (-> sv-16 elt-count)) 0)) (-> v1-70 0) 4.0))))))
  (let ((f30-2 (the float (-> this cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> this cycle-offset)
            (the uint (the int (* f30-2 (if (and v1-74 (< 1 (the int (-> sv-32 elt-count)))) (-> v1-74 1) 0.0)))))))
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> this cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the int (-> sv-48 elt-count)))) (-> v1-77 2) 2.0))))))
  (go electric-arc-active)
  (none))

(deftype crc-gondola (plat-eco)
  ((force-dest    float)
   (targ-dest     float)
   (dest          float)
   (speed         float)
   (touch-time    time-frame)
   (touching-time time-frame)))

(defskelgroup *crc-gondola-sg*
  flutflut-plat-med
  flutflut-plat-med-lod0-jg
  flutflut-plat-med-idle-ja
  ((flutflut-plat-med-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 9))

(defmethod get-unlit-skel ((this crc-gondola))
  *crc-gondola-sg*)

(defmethod baseplat-method-26 ((this crc-gondola))
  (set! (-> this force-dest) -1.0)
  (set! (-> this targ-dest) -1.0)
  (set! (-> this dest) 0.0)
  (set! (-> this speed) 0.08)
  (logclear! (-> this mask) (process-mask actor-pause))
  (process-entity-status! this (entity-perm-status bit-3) #t)
  (none))

;; particle effect override
(defmethod baseplat-method-20 ((this crc-gondola))
  (none))

(defun can-ride-gondola? ()
  (and (task-closed? (game-task crystalc-middle) (task-status need-resolution))
       (task-closed? (game-task crystalc-river) (task-status need-resolution))
       (task-closed? (game-task crystalc-ship) (task-status need-resolution))
       (task-closed? (game-task crystalc-shrooms) (task-status need-resolution))
       (task-closed? (game-task crystalc-hidden) (task-status need-resolution))
       (task-closed? (game-task crystalc-buzzer) (task-status need-resolution))))

(defstate plat-path-active (crc-gondola)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('target)
         (process-entity-status! self (entity-perm-status complete) #t)
         (set! (-> self force-dest) (the float (-> block param 0))))
        (('ridden)
         (if (zero? (-> self touching-time)) (set-time! (-> self touching-time)))
         (let ((idle? (or (<= (-> self path-pos) 0.0) (= 0.9999 (-> self path-pos))))
               (fnt (new 'stack 'font-context *font-default-matrix* 32 160 0.0 (font-color default) (font-flags shadow kerning))))
           (when (and (not (can-ride-gondola?)) (time-elapsed? (-> self touching-time) (seconds 3.5)))
             (set-width! fnt 448)
             (set-height! fnt 80)
             (set-scale! fnt 0.8)
             (set-flags! fnt (font-flags shadow kerning middle large))
             (print-game-text (lookup-text! *common-text* (text-id crystalc-gondola-need-cells) #f) fnt #f 128 22))
           (when (and (can-ride-gondola?) (hud-hidden?) (can-grab-display? self) idle?)
             (set-width! fnt 440)
             (set-height! fnt 80)
             (set-flags! fnt (font-flags shadow kerning large))
             (print-game-text (lookup-text! *common-text* (text-id press-to-use) #f) fnt #f 128 22)
             (when (and (cpad-pressed? 0 circle) (process-grab? *target*))
               (cpad-clear! 0 circle)
               (set! (-> self targ-dest)
                     (cond
                       ((= (-> self path-pos) 0.0) (set! (-> self force-dest) -1.0) 0.9999)
                       ((= (-> self path-pos) 0.9999) 0.0)
                       (else (-> self targ-dest)))))))
         (set-time! (-> self touch-time))
         #f)
        (else (plat-event proc argc message block))))
  :enter
    (behavior ((activated? plat))
      (set-time! (-> self state-time))
      (process-entity-status! self (entity-perm-status complete) #t))
  :trans
    (behavior ()
      ;; (format *stdcon* "touch time: ~e~%touching time ~e~%"  (- (current-time) (-> self touch-time)) (- (current-time) (-> self touching-time)))
      (when (and (not (task-closed? (game-task crystalc-gondola) (task-status need-resolution))) (can-ride-gondola?))
        (close-specific-task! (game-task crystalc-gondola) (task-status need-resolution)))
      (let ((path-fwd-step (eval-path-curve! (-> self path) (new-stack-vector0) 0.0 'interp))
            (path-bwd-step (eval-path-curve! (-> self path) (new-stack-vector0) 1.0 'interp))
            (tpos (target-pos 0)))
        (if (time-elapsed? (-> self touch-time) (seconds 3)) (set! (-> self targ-dest) -1.0))
        (set! (-> self dest)
              (cond
                ((>= (-> self force-dest) 0.0) (-> self force-dest))
                ((>= (-> self targ-dest) 0.0) (-> self targ-dest))
                ((< (vector-vector-xz-distance tpos path-fwd-step) (vector-vector-xz-distance tpos path-bwd-step)) 0.0)
                (else 0.9999))))
      (if (= (-> self state-time) (current-time)) (set! (-> self path-pos) (-> self dest)))
      (seek! (-> self path-pos)
             (-> self dest) ;; Set the speed of the platform along the path, hack to slow down the start
             (* (-> self speed)
                (cond
                  ((< (-> self path-pos) 0.05) (* (seconds-per-frame) 0.30))
                  ((< (-> self path-pos) 0.20) (* (seconds-per-frame) (lerp 0.30 1.0 (/ (- (-> self path-pos) 0.05) 0.15))))
                  (else (seconds-per-frame)))))
      (eval-path-curve! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
      (plat-trans)
      (let ((target-rider? (and (nonzero? (-> self root riders num-riders))
                                (= *target* (handle->process (-> self root riders rider 0 rider-handle))))))
        (when (not target-rider?)
          (set! (-> self touching-time) (seconds 0)))
        (when (and target-rider?
                   (nmember (the basic (send-event *target* 'query 'mode)) '(target-grab target-racing-grab))
                   (or (<= (-> self path-pos) 0.0) (= 0.9999 (-> self path-pos))))
          (process-release? *target*)))))
