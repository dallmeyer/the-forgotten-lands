;;-*-Lisp-*-
(in-package goal)

(deftype breakable-boulder (process-drawable)
  ((cshape collide-shape :overlay-at root)
   (broken-look lod-set :inline)
   )
  (:states
    breakable-boulder-break
    breakable-boulder-idle
    )
  )

(defskelgroup *breakable-boulder-whole-sg* shortcut-boulder shortcut-boulder-whole-lod0-jg shortcut-boulder-idle-ja
              ((shortcut-boulder-whole-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5.5 0 15.0)
              )

(defskelgroup *breakable-boulder-broken-sg* shortcut-boulder shortcut-boulder-broken-lod0-jg shortcut-boulder-idle-ja
              ((shortcut-boulder-broken-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5.5 0 20)
              )

(defstate breakable-boulder-break (breakable-boulder)
  :enter (behavior ()
    (sound-play "zoomer-explode")
    (none)
    )
  :code (behavior ()
    (process-entity-status! self (entity-perm-status complete) #t)
    (lods-assign! (-> self draw) (-> self broken-look))
    (process-spawn part-tracker :init part-tracker-init (-> *part-group-id-table* 903) -1 #f #f #f (-> self cshape trans)
      :to *entity-pool*
      )
    (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (cleanup-for-death self)
    (deactivate self)
    (none)
    )
  :post ja-post
  )

(defstate breakable-boulder-idle (breakable-boulder)
  :event (behavior ((proc process) (argc int) (event symbol) (msg event-message-block))
    (case event
      (('attack)
       (if (and (>= argc 2) (= (-> msg param 1) 'racer-red-boost))
           (go breakable-boulder-break)
           )
       )
      )
    )
  :code (behavior ()
    (transform-post)
    (anim-loop)
    (none)
    )
  )

(defmethod init-from-entity! ((this breakable-boulder) (entity entity-actor))
  (let ((cshape (new 'process 'collide-shape this (collide-list-enum hit-by-others))))
    (let ((prim-mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0))))
      (set! (-> prim-mesh prim-core collide-as) (collide-kind wall-object))
      (set! (-> prim-mesh collide-with) (collide-kind target))
      (set! (-> prim-mesh prim-core action) (collide-action solid))
      (set! (-> prim-mesh prim-core offense) (collide-offense indestructible))
      (set! (-> prim-mesh transform-index) 3)
      (set-vector! (-> prim-mesh local-sphere) (meters 0) (meters 5.5) (meters 0) (meters 7.5))
      (set-root-prim! cshape prim-mesh)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this cshape) cshape)
    )
  (process-drawable-from-entity! this entity)
  (initialize-skeleton this *breakable-boulder-whole-sg* '())
  (setup-lods! (-> this broken-look) *breakable-boulder-broken-sg* (-> this draw art-group) (-> this entity))
  (set-vector! (-> this draw color-emissive) 0.125 0.0625 0.0 0.0)
  (go breakable-boulder-idle)
  (none)
  )

(deftype mistycam (process-hidden)
  ()
  )

(defskelgroup *mistycam-sg* mistycam mistycam-lod0-jg mistycam-anim-ja
              ((mistycam-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 20)
              )

(defun mistycam-spawn ()
  (with-pp
    (let ((e (entity-actor-lookup (-> pp entity) 'alt-actor 0)))
      (when e
        (let* ((cam-handle
                 (ppointer->handle (process-spawn
                                     pov-camera
                                     (-> e extra trans)
                                     *mistycam-sg*
                                     (new 'static 'spool-anim :name "mistycam-cannon" :index 5 :parts 1 :command-list '())
                                     0
                                     #f
                                     '()
                                     :to pp
                                     )
                                   )
                 )
               (cell-handle (ppointer->handle
                       (process-spawn fuel-cell :init fuel-cell-init-as-clone cam-handle (-> pp entity extra perm task) :to pp)
                       )
                     )
               )
          (let ((cam (handle->process cam-handle)))
            (if cam
                (set! (-> (the pov-camera cam) notify-handle) cell-handle)
                )
            )
          (while (handle->process cam-handle)
            (suspend)
            )
          (send-event (handle->process cell-handle) 'stop-cloning)
          )
        )
      )
    0
    (none)
    )
  )

(deftype balloon-fuelcell (process-drawable)
  ((play-cutscene? symbol)
   )
  (:states
    balloon-fuelcell-die
    balloon-fuelcell-idle
    balloon-fuelcell-spawn
    )
  )


(defstate balloon-fuelcell-idle (balloon-fuelcell)
  :event (behavior ((proc process) (argc int) (event symbol) (msg event-message-block))
    (case event
      (('task-complete)
       (set! (-> self play-cutscene?) #t)
       (process-entity-status! self (entity-perm-status complete) #t)
       (go balloon-fuelcell-spawn)
       )
      )
    )
  :code anim-loop
  )

(defstate balloon-fuelcell-spawn (balloon-fuelcell)
  :event (the
    (function process int symbol event-message-block object :behavior balloon-fuelcell)
    process-drawable-fuel-cell-handler
    )
  :code (behavior ()
    (process-drawable-birth-fuel-cell (the entity #f) (the vector #f) #f)
    (when (and *target* (-> self play-cutscene?))
      (ambient-hint-spawn "gamcam02" (the vector #f) *entity-pool* 'camera)
      (let ((cam
              (ppointer->handle
                (process-spawn pov-camera (-> self root trans) *mistycam-sg* "mistycam-balloon-fuel-cell" 0 #f '() :to self)
                )
              )
            )
        (while (handle->process cam)
          (suspend)
          )
        )
      )
    (while (-> self child)
      (suspend)
      )
    (go balloon-fuelcell-die)
    (none)
    )
  )

(defstate balloon-fuelcell-die (balloon-fuelcell)
  :code (behavior ()
    (cleanup-for-death self)
    (none)
    )
  )

(defmethod init-from-entity! ((this balloon-fuelcell) (entity entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this entity)
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this play-cutscene?) #f)
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
      (go balloon-fuelcell-spawn)
      (go balloon-fuelcell-idle)
      )
  (none)
  )

(deftype enb-turbine (process-drawable)
  (
    (root-override  trsq        :overlay-at root)
    (sync           sync-info   :inline)
    (blade-normal   vector      :inline)
    (orig-quat      quaternion  :inline)
    (part2          sparticle-launch-control)
    )
  (:states
    enb-turbine-idle
    )
)

(defmethod relocate ((this enb-turbine) (off int))
  (if (nonzero? (-> this part2))
      (&+! (-> this part2) off)
      )
  (call-parent-method this off)
  )

(defmethod deactivate ((this enb-turbine))
  (if (nonzero? (-> this part2))
      (kill-and-free-particles (-> this part2))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defstate enb-turbine-idle (enb-turbine)
  :trans (behavior ()
    (cond
      ((= (get-task-status (-> self entity extra perm task)) (task-status invalid))
        (spawn (-> self part2) (-> self root-override trans))
        ;; (format 0 "energy-bay-turbine1 closed")
        )
      (else
        ;; (format 0 "energy-bay-turbine1 not closed")
      )
      )
    )
  :code anim-loop
  :post ja-post
  )

(defmethod init-from-entity! ((this enb-turbine) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask ambient))
  (load-params! (-> this sync) this (the-as uint 4800) 0.0 0.15 0.15)
  (set! (-> this root-override) (new 'process 'trsq))
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (quaternion-copy! (-> this orig-quat) (-> this root-override quat))
  (set! (-> this part2) (create-launch-control (-> *part-group-id-table* 906) this))
  (go enb-turbine-idle)
  (none)
  )