;;-*-Lisp-*-
(in-package goal)
(deftype lavabase (process-drawable) ()
  (:states
   lavabase-idle))

(defskelgroup *lavabase-sg*
  lavabase
  lavabase-lod0-jg
  lavabase-idle-ja
  ((lavabase-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 22)
  :longest-edge (meters 9.4))

(defstate lavabase-idle (lavabase)
  :code
    (behavior ()
      (loop
        (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))))
      (none))
  :post ja-post)

(defmethod init-from-entity! ((this lavabase) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *lavabase-sg* '())
  (go lavabase-idle)
  (none))

(deftype lavafall (process-drawable) ()
  (:states
   lavafall-idle))

(defskelgroup *lavafall-sg*
  lavafall
  lavafall-lod0-jg
  lavafall-idle-ja
  ((lavafall-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 50 0 53)
  :longest-edge (meters 5.4))

(defstate lavafall-idle (lavafall)
  :code
    (behavior ()
      (loop
        (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))))
      (none))
  :post ja-post)

(defmethod init-from-entity! ((this lavafall) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *lavafall-sg* '())
  (go lavafall-idle)
  (none))

(deftype cyclegen (structure) ;; cyclegen needed for the hutlamp
  ((output float)
   (inc float))
  :pack-me)

(defun set-period ((arg0 cyclegen) (arg1 int))
  (set! (-> arg0 inc) (/ 5.0 (the float arg1))))

(defun update-clock ((arg0 cyclegen))
  (let ((f0-1 (+ (-> arg0 output) (* (-> arg0 inc) (-> *display* time-adjust-ratio)))))
    (set! (-> arg0 output) (- f0-1 (the float (the int f0-1)))))
  (-> arg0 output))

(deftype hutlamp (process-drawable)
  ((pivot joint-mod-set-local)
   (clock cyclegen :inline))
  (:states
   hutlamp-idle))

(defmethod relocate hutlamp
  ((this hutlamp) (arg0 int))
  (if (nonzero? (-> this pivot)) (&+! (-> this pivot) arg0))
  (call-parent-method this arg0))

(defskelgroup *hutlamp-sg*
  hutlamp
  hutlamp-lod0-jg
  hutlamp-idle-ja
  ((hutlamp-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 1 0 1.2)
  :longest-edge (meters 0.7))

(defstate hutlamp-idle (hutlamp)
  :code
    (behavior ()
      (loop
        (let ((f0-3 (* 1820.4445 (sin (* 65536.0 (update-clock (-> self clock)))))))
          (quaternion-vector-angle! (-> self pivot transform quat) *x-vector* f0-3))
        (suspend))
      (none))
  :post ja-post)

(defmethod init-from-entity! ((this hutlamp) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *hutlamp-sg* '())
  (set! (-> this pivot) (new 'process 'joint-mod-set-local this 3 #f #t #f))
  (set-period (-> this clock) 900)
  (set! (-> this clock output) (rand-vu))
  (go hutlamp-idle)
  (none))

(deftype pusher-base (process-drawable)
  ((root      collide-shape-moving :override)
   (max-frame float)))

(deftype pusher (pusher-base)
  ((sync sync-info-paused :inline)
   (cyl  cylinder :inline))
  (:states
   pusher-idle))

(defskelgroup *pusher-sg*
  pusher
  pusher-lod0-jg
  pusher-idle-ja
  ((pusher-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 10))

(defbehavior pusher-base-init pusher-base ()
  (logior! (-> self mask) (process-mask enemy platform))
  (let ((gp-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-others))))
    (set! (-> gp-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> gp-0 reaction) default-collision-reaction)
    (set! (-> gp-0 no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s5-0 (new 'process 'collide-shape-prim-group gp-0 (the uint 1) 0)))
      (set! (-> s5-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s5-0 collide-with) (collide-kind target))
      (set! (-> s5-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s5-0 transform-index) 0)
      (set-vector! (-> s5-0 local-sphere) -8192.0 0.0 0.0 40960.0)
      (set-root-prim! gp-0 s5-0)
      (let ((s4-0 (new 'process 'collide-shape-prim-mesh gp-0 (the uint 0) (the uint 0))))
        (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s4-0 collide-with) (collide-kind target))
        (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s4-0 transform-index) 4)
        (set-vector! (-> s4-0 local-sphere) 8192.0 0.0 0.0 28672.0)
        (append-prim s5-0 s4-0)))
    (set! (-> gp-0 nav-radius) (* 0.75 (-> gp-0 root-prim local-sphere w)))
    (backup-collide-with-as gp-0)
    (set! (-> self root) gp-0)
    gp-0))

(defstate pusher-idle (pusher)
  :trans rider-trans
  :code
    (behavior ()
      (loop
        (let ((f0-0 -1.0))
          (when (and *target* *camera*)
            (let ((gp-0 (new 'stack-no-clear 'vector)))
              (vector-! gp-0 (target-pos 0) (camera-pos))
              (set! f0-0 (ray-capsule-intersect (-> self cyl) (camera-pos) gp-0))))
          (if (< f0-0 0.0)
            (ja :num! (seek! (get-current-value-with-mirror (-> self sync) (-> self max-frame))))
            (ja :num! (seek! 0.0))))
        (suspend))
      (none))
  :post rider-post)

(defmethod init-from-entity! ((this pusher) (arg0 entity-actor))
  (pusher-base-init)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *pusher-sg* '())
  (load-params! (-> this sync) this (the uint 1500) 0.0 0.15 0.15)
  (set! (-> this max-frame) (res-lump-float arg0 'max-frame :default (the float (ja-num-frames 0))))
  (set! (-> this cyl origin quad) (-> this root trans quad))
  (vector-x-quaternion! (-> this cyl axis) (-> this root quat))
  (vector-negate! (-> this cyl axis) (-> this cyl axis))
  (set! (-> this cyl length) 36864.0)
  (set! (-> this cyl radius) 20480.0)
  (go pusher-idle)
  (none))

(deftype villagec-lava (water-anim) ())

(define ripple-for-villagec-lava
  (new 'static
       'ripple-wave-set
       :count 2
       :converted #f
       :wave
       (new 'static
            'inline-array
            ripple-wave
            4
            (new 'static 'ripple-wave :scale 40.0 :xdiv 2 :speed 1.5)
            (new 'static 'ripple-wave :scale 40.0 :xdiv -2 :zdiv 2 :speed 0.9)
            (new 'static 'ripple-wave)
            (new 'static 'ripple-wave))))

(defmethod water-vol-method-22 ((this villagec-lava))
  (call-parent-method this)
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> this draw ripple) v1-2)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 waveform) ripple-for-villagec-lava))
  (logclear! (-> this flags) (water-flags wt23))
  (logior! (-> this flags) (water-flags wt25))
  (set! (-> this attack-event) 'lava)
  (none))

(deftype chainmine (process-drawable)
  ((root collide-shape-moving :override))
  (:state-methods
   die
   idle))

(defpartgroup group-chainmine-explode
  :id 542
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts
  ((sp-item 2132 :period (seconds 2) :length (seconds 0.017))
   (sp-item 2133 :period (seconds 2) :length (seconds 0.135))
   (sp-item 2134 :period (seconds 2) :length (seconds 0.067))
   (sp-item 2135 :period (seconds 2) :length (seconds 0.067))))

(defpart 2133
  :init-specs
  ((:texture (new 'static 'texture-id :index #xf :page #x2))
   (:num 8.0)
   (:y (meters 0))
   (:scale-x (meters 0.4) (meters 0.8))
   (:scale-y :copy scale-x)
   (:r 192.0 64.0)
   (:g 192.0 64.0)
   (:b 128.0)
   (:a 32.0 96.0)
   (:vel-y (meters 0.053333335) (meters 0.21333334))
   (:scalevel-x (meters -0.0026666666))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -2.1333334)
   (:fade-b -1.4222223)
   (:accel-y (meters -0.00016666666) (meters -0.00016666666))
   (:friction 0.9)
   (:timer (seconds 1))
   (:flags (bit2 bit14))
   (:next-time (seconds 0.1) (seconds 0.297))
   (:next-launcher 2136)
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 2) (meters 4))))

(defpart 2136
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:fade-a -1.0666667)))

(defpart 2135
  :init-specs
  ((:texture (new 'static 'texture-id :index #xf :page #x2))
   (:num 6.0)
   (:y (meters 0))
   (:scale-x (meters 0.4))
   (:rot-z (degrees 0) (degrees 180))
   (:scale-y (meters 16))
   (:r 255.0)
   (:g 196.0)
   (:b 64.0)
   (:a 32.0 64.0)
   (:scalevel-y (meters 1.04))
   (:fade-g -3.2666667)
   (:fade-b -1.0666667)
   (:fade-a -1.6)
   (:timer (seconds 0.2))
   (:flags (bit2 bit3 bit14))))

(defpart 2132
  :init-specs
  ((:texture (new 'static 'texture-id :index #x12 :page #x2))
   (:num 1.0)
   (:y (meters 0))
   (:scale-x (meters 32))
   (:scale-y :copy scale-x)
   (:r 255.0)
   (:g 192.0 32.0)
   (:b 128.0)
   (:a 128.0)
   (:fade-a -2.3272727)
   (:timer (seconds 0.18))
   (:flags (bit2 bit3 bit14))))

(defpart 2134
  :init-specs
  ((:texture (new 'static 'texture-id :page #x2))
   (:num 16.0)
   (:scale-x (meters 4) (meters 2))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 255.0)
   (:g 128.0 64.0)
   (:b 128.0)
   (:a 64.0 64.0)
   (:vel-y (meters 0.08) (meters 0.04))
   (:scalevel-x (meters 0.02))
   (:rotvel-z (degrees -0.6) (degrees 1.2))
   (:scalevel-y :copy scalevel-x)
   (:fade-a -0.28444445)
   (:accel-y (meters 0.00016666666) (meters 0.00016666666))
   (:friction 0.8)
   (:timer (seconds 1.7))
   (:flags (bit2 bit14))
   (:next-time (seconds 0.14))
   (:next-launcher 2137)
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 0) (meters 2))))

(defpart 2137
  :init-specs ((:fade-r -1.0666667) (:fade-g -1.0666667) (:fade-b -2.1166666) (:next-time (seconds 0.2)) (:next-launcher 2138)))

(defpart 2138
  :init-specs
  ((:fade-r -0.5688889)
   (:fade-g -0.28444445)
   (:fade-b 0.0)
   (:fade-a -0.21333334)
   (:next-time (seconds 0.75))
   (:next-launcher 2139)))

(defpart 2139
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0)))

(defskelgroup *chainmine-sg*
  chainmine
  chainmine-lod0-jg
  chainmine-idle-ja
  ((chainmine-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 -10.75 0 12.75)
  :longest-edge (meters 2.4))

(defstate die (chainmine)
  :virtual #t
  :code
    (behavior ()
      (ja-channel-set! 0)
      (clear-collide-with-as (-> self root))
      (ja-post)
      (sound-play "dcrate-break")
      (let ((gp-1 (new 'stack-no-clear 'vector)))
        (set! (-> gp-1 quad) (-> self root trans quad))
        (+! (-> gp-1 y) -73728.0)
        (process-spawn part-tracker :init part-tracker-init (-> *part-group-id-table* 542) 600 #f #f #f gp-1 :to *entity-pool*))
      (suspend)
      (set! (-> self state-time) (-> *display* base-frame-counter))
      (until (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 1))
        (suspend))
      (cleanup-for-death self)
      (deactivate self)
      (none)))

(defstate idle (chainmine)
  :virtual #t
  :event
    (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
      (case event-type
        (('attack 'touch) (send-event proc 'attack (-> event param 0) (static-attack-info ((mode 'deadly)))) (go-virtual die))))
  :code
    (behavior ()
      (loop
        (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (if (nonzero? (-> self sound)) (update! (-> self sound)))
          (suspend)
          (ja :num! (seek!))))
      (none))
  :post ja-post)

(defmethod init-from-entity! ((this chainmine) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask attackable))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 -73728.0 0.0 18432.0)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *chainmine-sg* '())
  (set! (-> this sound) (new 'process 'ambient-sound (static-sound-spec "lava-mine-chain" :fo-max 30) (-> this root trans)))
  (go (method-of-object this idle))
  (none))

(deftype bladeassm (process-drawable)
  ((root  collide-shape-moving :override)
   (angle float))
  (:states
   bladeassm-idle))

(defskelgroup *bladeassm-sg*
  bladeassm
  bladeassm-lod0-jg
  bladeassm-idle-ja
  ((bladeassm-lod0-mg (meters 20)) (bladeassm-lod1-mg (meters 40)) (bladeassm-lod2-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 16)
  :longest-edge (meters 10))

(defstate bladeassm-idle (bladeassm)
  :code
    (behavior ()
      (loop
        (+! (-> self angle) (* 3640.889 (-> *display* seconds-per-frame)))
        (set! (-> self angle) (the float (sar (shl (the int (-> self angle)) 48) 48)))
        (pusher-post)
        (suspend))
      (none)))

(defun bladeassm-prebind-function ((arg0 process-drawable) (arg1 int) (arg2 bladeassm) (arg3 event-message-block))
  (let ((v1-0 arg2)) (quaternion-axis-angle! (the quaternion (&-> arg0 link)) 0.0 0.0 1.0 (-> v1-0 angle)))
  0)

(defmethod init-from-entity! bladeassm
  ((this bladeassm) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask ambient))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the uint 0) (the uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 49152.0)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *bladeassm-sg* '())
  (set! (-> this skel prebind-function) (the (function pointer int process-drawable none) bladeassm-prebind-function))
  (logclear! (-> this mask) (process-mask actor-pause))
  (go bladeassm-idle)
  (none))

(deftype caveflamepots (process-drawable)
  ((root               collide-shape :override)
   (shove-up           float)
   (cycle-speed        int32)
   (cycle-pause        int32)
   (cycle-offset       uint32)
   (was-deadly?        symbol)
   (should-play-sound? symbol)
   (launch-pos         vector 2 :inline))
  (:states
   caveflamepots-active))

(defpart 704
  :init-specs
  ((:texture (new 'static 'texture-id :page #x2))
   (:num 1.0)
   (:x (meters -1.2) (meters 2.4))
   (:z (meters -1.2) (meters 2.4))
   (:scale-x (meters 4))
   (:rot-z (degrees -180) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 0.0)
   (:a 128.0)
   (:vel-y (meters 0.06) (meters 0.015))
   (:scalevel-x (meters -0.0039999997))
   (:rotvel-z (degrees -1.8) (degrees 1.8))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -0.8)
   (:fade-a -0.55333335)
   (:accel-y (meters -0.0006))
   (:timer (seconds 16.68))
   (:flags (bit2 bit3))))

(defstate caveflamepots-active (caveflamepots)
  :event
    (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
      (case event-type
        (('touch 'attack)
         (when (= (-> proc type) target)
           (when ((method-of-type touching-shapes-entry prims-touching-action?)
                  (the touching-shapes-entry (-> event param 0))
                  (-> *target* control)
                  (collide-action solid)
                  (collide-action))
             (let ((s4-0 (new 'stack 'attack-info)))
               (calc-shove-up (-> self root) s4-0 (-> self shove-up))
               (if (or (= (-> *target* control unknown-surface00 mode) 'air)
                       (>= (+ (-> *display* base-frame-counter) (seconds -0.2)) (-> *target* control unknown-dword11))
                       (< 0.75 (-> *target* control poly-normal y)))
                 (send-event proc
                             'attack-or-shove
                             (-> event param 0)
                             (static-attack-info ((mode 'burn) (vector (-> s4-0 vector)) (shove-up (-> s4-0 shove-up)))))
                 (send-event proc
                             'attack-or-shove
                             (-> event param 0)
                             (static-attack-info ((mode 'burn) (shove-up (meters 0)) (shove-back (meters 2)) (vector (-> *target* control poly-normal)) (angle 'shove)))))))))))
  :trans
    (behavior ()
      (let* ((v1-0 (-> self cycle-speed))
             (a0-1 (- v1-0 (-> self cycle-pause)))
             (gp-0 (mod (+ (-> *display* base-frame-counter) (the time-frame (-> self cycle-offset))) v1-0)))
        (cond
          ((< gp-0 a0-1)
           (when (sphere-in-view-frustum? (the sphere (-> self root root-prim prim-core)))
             (launch-particles (-> *part-id-table* 704) (the vector (-> self launch-pos))))
           (when (-> self should-play-sound?)
             (set! (-> self should-play-sound?) #f)
             (sound-play "hot-flame"))
           (cond
             ((< gp-0 30) (when (-> self was-deadly?) (set! (-> self was-deadly?) #f) (clear-collide-with-as (-> self root))))
             (else (when (not (-> self was-deadly?)) (set! (-> self was-deadly?) #t) (restore-collide-with-as (-> self root)))))
           (when (and (not (-> self was-deadly?)) (< 60 gp-0))
             (set! (-> self was-deadly?) #t)
             (restore-collide-with-as (-> self root))))
          (else
           (set! (-> self should-play-sound?) #t)
           (when (-> self was-deadly?)
             (set! (-> self was-deadly?) #f)
             (clear-collide-with-as (-> self root))))))
      (none))
  :code
    (behavior ()
      (loop
        (logior! (-> self mask) (process-mask sleep-code))
        (suspend))
      (none)))

(defmethod init-from-entity! ((this caveflamepots) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> this was-deadly?) #f)
  (set! (-> this should-play-sound?) #f)
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default (meters 5.0)))
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 (meters 7) 0.0 (meters 5))
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-0 local-sphere) 0.0 (meters 3) 0.0 (meters 2))
        (append-prim s3-0 s2-0))
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-1 local-sphere) 0.0 (meters 6) 0.0 (meters 2))
        (append-prim s3-0 s2-1)))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0))
  (process-drawable-from-entity! this arg0)
  (let ((v1-42 (new 'process 'path-control this 'path 0.0)))
    (set! (-> this path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0) (go process-drawable-art-error "no path")))
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0) (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-23)))
  (let ((f30-0 (quaternion-y-angle (-> this root quat))))
    (let ((s4-1 (-> this launch-pos)))
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) 0.0)
        (set! (-> v1-53 0 y) 0.0)
        (set! (-> v1-53 0 z) 0.0)
        (set! (-> v1-53 0 w) 1.0))
      (vector-rotate-around-y! (the vector s4-1) (the vector s4-1) f30-0)
      (vector+! (the vector s4-1) (the vector s4-1) (-> this root trans)))
    (let ((s4-2 (the object (&-> this stack 112))))
      (set-vector! (the vector s4-2) -6144.0 0.0 0.0 1.0)
      (vector-rotate-around-y! (the vector s4-2) (the vector s4-2) f30-0)
      (vector+! (the vector s4-2) (the vector s4-2) (-> this root trans)))
    (let ((s4-3 (-> this root root-prim)))
      (dotimes (s3-1 (-> (the collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)))))
  (update-transforms! (-> this root))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> this cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the int (-> sv-16 elt-count)) 0)) (-> v1-70 0) 4.0))))))
  (let ((f30-2 (the float (-> this cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> this cycle-offset)
            (the uint (the int (* f30-2 (if (and v1-74 (< 1 (the int (-> sv-32 elt-count)))) (-> v1-74 1) 0.0)))))))
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> this cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the int (-> sv-48 elt-count)))) (-> v1-77 2) 2.0))))))
  (go caveflamepots-active)
  (none))

(deftype towertop (process-drawable)
  ((root-override trsq :overlay-at root))
  (:states
   towertop-idle))

(defskelgroup *towertop-sg*
  towertop
  towertop-lod0-jg
  towertop-idle-ja
  ((towertop-lod0-mg (meters 20)) (towertop-lod1-mg (meters 40)) (towertop-lod2-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 30))

(defstate towertop-idle (towertop)
  :code
    (behavior ()
      (loop
        (ja-no-eval :group! towertop-idle-ja :num! (seek! max 0.4) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max 0.4))))
      (none))
  :post ja-post)

(defmethod init-from-entity! ((this towertop) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask ambient))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton this *towertop-sg* '())
  (go towertop-idle)
  (none))

(deftype mayorgears (process-drawable)
  ((alt-actor entity-actor))
  (:states
   mayorgears-idle))

(defskelgroup *mayorgears-sg*
  mayorgears
  mayorgears-geo-jg
  mayorgears-idle-ja
  ((mayorgears-geo-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4.5))

(defstate mayorgears-idle (mayorgears)
  :code
    (behavior ()
      (loop
        (ja :num! (loop!))
        (ja :num! (loop! 0.0))
        (suspend))
      (none))
  :post ja-post)

(defmethod init-from-entity! ((this mayorgears) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask ambient))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *mayorgears-sg* '())
  (set! (-> this draw shadow-mask) (the uint 255))
  (go mayorgears-idle)
  (none))

(deftype lava-plat (plat)
  ((sink-part                sparticle-launch-control)
   (emerge-part              sparticle-launch-control)
   (part-sink-spawn-height   float)
   (part-emerge-spawn-height float)
   (part-range               float)))

(defmethod init-from-entity! ((this lava-plat) (ent entity-actor))
  (logior! (-> this mask) (process-mask platform))
  (baseplat-method-24 this)
  (process-drawable-from-entity! this ent)
  (initialize-skeleton this (get-unlit-skel this) '())
  (logior! (-> this skel status) (janim-status inited))
  (update-transforms! (-> this root))
  (baseplat-method-21 this)
  (baseplat-method-25 this)
  (load-params! (-> this sync) this (the uint 0) 0.0 0.15 0.15)
  (set! (-> this fact) (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc)))
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this sink-part) (create-launch-control (-> *part-group-id-table* 870) this))
  (set! (-> this emerge-part) (create-launch-control (-> *part-group-id-table* 871) this))
  (set! (-> this part-sink-spawn-height) (res-lump-float (-> this entity) 'part-height :default 0.0))
  (set! (-> this part-emerge-spawn-height) (res-lump-float (-> this entity) 'part-emerge-height :default 0.0))
  (set! (-> this part-range) (res-lump-float (-> this entity) 'part-range :default 0.0))
  (cond
    ((logtest? (-> this path flags) (path-control-flag not-found))
     (set! (-> this path-pos) 0.0)
     (baseplat-method-26 this)
     (go (method-of-object this plat-startup) this))
    ((> (-> this sync period) 0)
     (set! (-> this path-pos)
           (if (logtest? (-> this fact options) (fact-options wrap-phase))
             (get-current-phase (-> this sync))
             (get-current-phase-with-mirror (-> this sync))))
     (eval-path-curve! (-> this path) (-> this root trans) (-> this path-pos) 'interp)
     (baseplat-method-26 this)
     (go (method-of-object this plat-startup) this))
    (else
     (set! (-> this path-pos) 0.0)
     (eval-path-curve! (-> this path) (-> this root trans) (-> this path-pos) 'interp)
     (baseplat-method-26 this)
     (go (method-of-object this plat-startup) this)))
  (none))

(defmethod relocate ((this lava-plat) (off int))
  (if (nonzero? (-> this sink-part)) (&+! (-> this sink-part) off))
  (if (nonzero? (-> this emerge-part)) (&+! (-> this emerge-part) off))
  (call-parent-method this off))

(defstate plat-path-active (lava-plat)
  :virtual #t
  :event plat-event
  :exit
    (behavior ()
      (sound-stop (-> self sound-id)))
  :trans
    (behavior ()
      (set! (-> self path-pos)
            (if (logtest? (-> self fact options) (fact-options wrap-phase))
              (get-current-phase (-> self sync))
              (get-current-phase-with-mirror (-> self sync))))
      (let ((old-y (-> self basetrans y)))
        (eval-path-curve! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
        (if (< (vector-vector-distance (-> self root trans) (ear-trans)) (meters 20))
          (sound-play "eco-plat-hover" :id (-> self sound-id) :position (the symbol (-> self root trans))))
        (let* ((new-y (-> self basetrans y))
               (sink? (> (- old-y new-y) 0.0))
               (y (-> self root trans y))
               (half (/ (-> self part-range) 2.0))
               (emerge-y (- (- (-> self part-emerge-spawn-height) half) y))
               (sink-y (+ (-> self part-sink-spawn-height) half))
               (in-range? (if sink? (< (- y sink-y) half) (and (< emerge-y half) (< (- y (-> self part-sink-spawn-height)) half)))))
          ;; (when (string= (the string (-> self name)) "crescent-plat-10")
          ;;   (format *stdcon* "plat y ~m~%sink? ~A~%in-range? ~A~%dist ~m~%"
          ;;     y sink? in-range?
          ;;     (- y (-> self part-sink-spawn-height))
          ;;     )
          ;;   (format *stdcon* "half ~m~%dist sink ~m~%dist emerge ~m~%old y ~f~%new y ~f~%delta ~f"
          ;;     half
          ;;     (- y (+ (-> self part-sink-spawn-height) half))
          ;;     (- (- (-> self part-sink-spawn-height) half) y)
          ;;     old-y
          ;;     new-y
          ;;     (- old-y new-y)
          ;;     )
          ;;   )
          (when in-range?
            (let ((part-pos (new-stack-vector0)))
              (vector-copy! part-pos (-> self root trans))
              (set! (-> part-pos y) (-> self part-sink-spawn-height))
              (if sink? (spawn (-> self sink-part) part-pos) (spawn (-> self emerge-part) (-> self root trans)))))))
      (plat-trans))
  :code
    (the (function plat object)
         anim-loop)
  :post plat-post)
